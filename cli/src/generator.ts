import fs from 'node:fs/promises';
import path from 'node:path';
import type { AssetFile, AssetsGenConfig, Logger } from './types.js';
import { createNestedObject, deepMerge, generateTypeDefinition } from './utils.js';

/**
 * Generates the TypeScript assets file
 */
export async function generateAssetsFile(
  assets: AssetFile[],
  config: AssetsGenConfig,
  projectRoot: string,
  logger: Logger
): Promise<void> {
  logger.info('Generating assets file...');

  // Build nested object structure
  const assetsObject = buildAssetsObject(assets, config, projectRoot);

  // Generate TypeScript code
  const code = generateTypeScriptCode(assetsObject, config);

  // Ensure output directory exists
  const outputPath = path.resolve(projectRoot, config.output);
  const outputDir = path.dirname(outputPath);
  await fs.mkdir(outputDir, { recursive: true });

  // Write file
  await fs.writeFile(outputPath, code, 'utf-8');

  logger.success(`Generated: ${config.output}`);
}

/**
 * Builds a nested object structure from asset files
 */
function buildAssetsObject(assets: AssetFile[], config: AssetsGenConfig, projectRoot: string): any {
  let result = {};

  const outputPath = path.resolve(projectRoot, config.output);
  const outputDir = path.dirname(outputPath);

  for (const asset of assets) {
    // Calculate relative import path from output file to asset
    let relativePath = path.relative(outputDir, asset.absolutePath);
    
    // Normalize to forward slashes and ensure it starts with ./
    relativePath = relativePath.split(path.sep).join('/');
    if (!relativePath.startsWith('.')) {
      relativePath = './' + relativePath;
    }

    const nestedObj = createNestedObject(asset.pathSegments, relativePath);
    result = deepMerge(result, nestedObj);
  }

  return result;
}

/**
 * Generates the complete TypeScript code
 */
function generateTypeScriptCode(assetsObject: any, config: AssetsGenConfig): string {
  const lines: string[] = [];

  // File header
  lines.push('/**');
  lines.push(' * AUTO-GENERATED FILE - DO NOT EDIT');
  lines.push(' * Generated by react-assets-gen');
  lines.push(` * Generated at: ${new Date().toISOString()}`);
  lines.push(' */');
  lines.push('');

  // Collect all assets to generate imports
  const allAssets = collectAllAssets(assetsObject);
  const assetImports = new Map<string, string>(); // path -> identifier

  // Generate imports
  if (config.svg?.asComponent) {
    lines.push('// SVG React Components');
    for (const { path: assetPath, identifier } of allAssets) {
      if (assetPath.endsWith('.svg')) {
        lines.push(`import ${identifier}ReactComponent from '${assetPath}?react';`);
      }
    }
    lines.push('');
  }

  // Generate asset imports
  for (const { path: assetPath, identifier } of allAssets) {
    lines.push(`import ${identifier} from '${assetPath}';`);
    assetImports.set(assetPath, identifier);
  }
  lines.push('');

  // Generate type definition
  lines.push('/**');
  lines.push(' * Type-safe assets object');
  lines.push(' */');
  lines.push('export interface AssetsType {');
  lines.push(generateTypeDefinition(assetsObject, 0));
  lines.push('}');
  lines.push('');

  // Generate assets object
  lines.push('/**');
  lines.push(' * Assets object containing all asset paths');
  lines.push(' * @example');
  lines.push(' * import { Assets } from "./generated/assets";');
  lines.push(' * <img src={Assets.images.logo} alt="Logo" />');
  lines.push(' */');
  
  lines.push('export const Assets: AssetsType = {');
  lines.push(generateObjectLiteral(assetsObject, 1, assetImports));
  lines.push('} as const;');
  lines.push('');

  // SVG Components export (if enabled)
  if (config.svg?.asComponent) {
    const svgAssets = allAssets.filter(a => a.path.endsWith('.svg'));
    if (svgAssets.length > 0) {
      lines.push('/**');
      lines.push(' * SVG React Components');
      lines.push(' * @example');
      lines.push(' * import { SvgComponents } from "./generated/assets";');
      lines.push(' * <SvgComponents.icons.close />');
      lines.push(' */');
      lines.push('export const SvgComponents = {');
      
      for (const { identifier } of svgAssets) {
        lines.push(`  ${identifier}: ${identifier}ReactComponent,`);
      }
      
      lines.push('} as const;');
      lines.push('');
    }
  }

  // Default export
  lines.push('export default Assets;');
  lines.push('');

  return lines.join('\n');
}

/**
 * Helper to collect all assets with unique identifiers
 */
function collectAllAssets(obj: any, prefix: string = ''): Array<{ path: string, identifier: string }> {
  const results: Array<{ path: string, identifier: string }> = [];

  for (const [key, value] of Object.entries(obj)) {
    // Create a base identifier from the key
    // If we have a prefix (parent keys), append the current key capitalized
    // e.g. icons -> react becomes iconsReact
    const identifierBase = prefix 
      ? `${prefix}${key.charAt(0).toUpperCase()}${key.slice(1)}` 
      : key;

    if (typeof value === 'string') {
      // It's an asset path
      results.push({ path: value, identifier: identifierBase });
    } else if (typeof value === 'object' && value !== null) {
      results.push(...collectAllAssets(value, identifierBase));
    }
  }

  return results;
}

/**
 * Generates object literal code from nested structure using imported identifiers
 */
function generateObjectLiteral(obj: any, indentLevel: number, assetImports: Map<string, string>): string {
  const indent = '  '.repeat(indentLevel);
  const entries: string[] = [];

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      const identifier = assetImports.get(value);
      if (identifier) {
        entries.push(`${indent}${key}: ${identifier},`);
      } else {
        // Fallback (shouldn't happen if logic is correct)
        entries.push(`${indent}${key}: '${value}',`);
      }
    } else if (typeof value === 'object' && value !== null) {
      entries.push(`${indent}${key}: {`);
      entries.push(generateObjectLiteral(value, indentLevel + 1, assetImports));
      entries.push(`${indent}},`);
    }
  }

  return entries.join('\n');
}
