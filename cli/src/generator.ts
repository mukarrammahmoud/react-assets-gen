import fs from 'node:fs/promises';
import path from 'node:path';
import type { AssetFile, AssetsGenConfig, Logger } from './types.js';
import { createNestedObject, deepMerge, generateTypeDefinition } from './utils.js';

/**
 * Generates the TypeScript assets file
 */
export async function generateAssetsFile(
  assets: AssetFile[],
  config: AssetsGenConfig,
  projectRoot: string,
  logger: Logger
): Promise<void> {
  logger.info('Generating assets file...');

  // Build nested object structure
  const assetsObject = buildAssetsObject(assets, config, projectRoot);

  // Generate TypeScript code
  const code = generateTypeScriptCode(assetsObject, config);

  // Ensure output directory exists
  const outputPath = path.resolve(projectRoot, config.output);
  const outputDir = path.dirname(outputPath);
  await fs.mkdir(outputDir, { recursive: true });

  // Write file
  await fs.writeFile(outputPath, code, 'utf-8');

  logger.success(`Generated: ${config.output}`);
}

/**
 * Builds a nested object structure from asset files
 */
function buildAssetsObject(assets: AssetFile[], config: AssetsGenConfig, projectRoot: string): any {
  let result = {};

  const outputPath = path.resolve(projectRoot, config.output);
  const outputDir = path.dirname(outputPath);

  for (const asset of assets) {
    // Calculate relative import path from output file to asset
    let relativePath = path.relative(outputDir, asset.absolutePath);
    
    // Normalize to forward slashes and ensure it starts with ./
    relativePath = relativePath.split(path.sep).join('/');
    if (!relativePath.startsWith('.')) {
      relativePath = './' + relativePath;
    }

    const nestedObj = createNestedObject(asset.pathSegments, relativePath);
    result = deepMerge(result, nestedObj);
  }

  return result;
}

/**
 * Generates the complete TypeScript code
 */
function generateTypeScriptCode(assetsObject: any, config: AssetsGenConfig): string {
  const lines: string[] = [];

  // File header
  lines.push('/**');
  lines.push(' * AUTO-GENERATED FILE - DO NOT EDIT');
  lines.push(' * Generated by react-assets-gen');
  lines.push(` * Generated at: ${new Date().toISOString()}`);
  lines.push(' */');
  lines.push('');

  // SVG component imports (if enabled)
  if (config.svg?.asComponent) {
    lines.push('// SVG React Components');
    const svgAssets = collectSvgAssets(assetsObject);
    for (const [identifier, importPath] of svgAssets) {
      lines.push(`import ${identifier}Component from '${importPath}?react';`);
    }
    if (svgAssets.length > 0) {
      lines.push('');
    }
  }

  // Generate type definition
  lines.push('/**');
  lines.push(' * Type-safe assets object');
  lines.push(' */');
  lines.push('export interface AssetsType {');
  lines.push(generateTypeDefinition(assetsObject, 0));
  lines.push('}');
  lines.push('');

  // Generate assets object
  lines.push('/**');
  lines.push(' * Assets object containing all asset paths');
  lines.push(' * @example');
  lines.push(' * import { Assets } from "./generated/assets";');
  lines.push(' * <img src={Assets.images.logo} alt="Logo" />');
  lines.push(' */');
  lines.push('export const Assets: AssetsType = {');
  lines.push(generateObjectLiteral(assetsObject, 1));
  lines.push('} as const;');
  lines.push('');

  // SVG Components export (if enabled)
  if (config.svg?.asComponent) {
    const svgAssets = collectSvgAssets(assetsObject);
    if (svgAssets.length > 0) {
      lines.push('/**');
      lines.push(' * SVG React Components');
      lines.push(' * @example');
      lines.push(' * import { SvgComponents } from "./generated/assets";');
      lines.push(' * <SvgComponents.icons.close />');
      lines.push(' */');
      lines.push('export const SvgComponents = {');
      for (const [identifier] of svgAssets) {
        lines.push(`  ${identifier}: ${identifier}Component,`);
      }
      lines.push('} as const;');
      lines.push('');
    }
  }

  // Default export
  lines.push('export default Assets;');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generates object literal code from nested structure
 */
function generateObjectLiteral(obj: any, indentLevel: number): string {
  const indent = '  '.repeat(indentLevel);
  const entries: string[] = [];

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      entries.push(`${indent}${key}: '${value}',`);
    } else if (typeof value === 'object' && value !== null) {
      entries.push(`${indent}${key}: {`);
      entries.push(generateObjectLiteral(value, indentLevel + 1));
      entries.push(`${indent}},`);
    }
  }

  return entries.join('\n');
}

/**
 * Collects all SVG assets for component generation
 */
function collectSvgAssets(obj: any, prefix: string = ''): Array<[string, string]> {
  const results: Array<[string, string]> = [];

  for (const [key, value] of Object.entries(obj)) {
    const identifier = prefix ? `${prefix}${key.charAt(0).toUpperCase()}${key.slice(1)}` : key;

    if (typeof value === 'string' && value.endsWith('.svg')) {
      results.push([identifier, value]);
    } else if (typeof value === 'object' && value !== null) {
      results.push(...collectSvgAssets(value, identifier));
    }
  }

  return results;
}
